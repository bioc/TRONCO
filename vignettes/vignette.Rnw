\documentclass[a4paper, 9pt]{article}


<<style-Sweave, eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex()
@

%% \VignetteIndexEntry{An R Package for TRanslational ONCOlogy}



\usepackage{hyperref}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{xfrac}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\usepackage[table]{xcolor} %http://ctan.org/pkg/xcolor

\usepackage[numbers]{natbib}
\usepackage{algorithmic}
\usepackage{algorithm}

\usepackage{url}

\usepackage{placeins}
\usepackage{blindtext}

\usepackage[many]{tcolorbox}
%\tcbuselibrary{listings}
%\tcbuselibrary{minted}



\definecolor{mycolor}{rgb}{0.35, 0.169, 0.73}
%\definecolor{mycolor}{rgb}{0.171, 0.198, 0.81}

\newtcolorbox{mybox}[1][]
{
%  colframe = cyan,
%  colback  = cyan!10,
  colframe = black!75!white,
  colback  = blue!5!white,
  fontupper=\fontsize{3mm}{3mm}\selectfont\bfseries\sffamily,
  breakable,
  %  listing engine=minted,
%  minted language=R,
%  minted style=trac,
%  minted options={fontsize=\small,linenos,numbersep=3mm},
%  listing only
  #1
}


\usepackage{xspace}

\newcommand{\CAPRESE}{\textsc{CAPRESE}}
\newcommand{\TRONCO}{\textsc{TRONCO}}

\usepackage{fullpage}

\begin{document}

\title{Using the \TRONCO{} package}

\author{
Marco Antoniotti\footnote{Dipartimento di Informatica Sistemistica e Comunicazione, Universit√† degli Studi Milano Bicocca
Milano, Italy.} \and
Giulio Caravagna$^\ast$ \and
Luca De Sano$^\ast$ \and
Alex Graudenzi$^\ast$ \and
%Mattia Longoni$^\ast$ \and
Giancarlo Mauri$^\ast$ \and
Bud Mishra\footnote{Courant Institute of Mathematical Sciences, New York University, New York, USA.} \and
Daniele Ramazzotti$^\ast$ 
}

\date{\today}
\maketitle


\begin{tcolorbox}{\bf Overview.} The \TRONCO{} ({\sc TR}{\em anslational} {\sc ONCO}{\em logy})  \textsc{R} package  collects algorithms to infer  progression models via the approach of Suppes-Bayes Causal Network, both from an ensemble of tumors (cross-sectional samples) and within an individual patient (multi-region or single-cell samples). The package provides parallel implementation of algorithms that process binary matrices where each row represents a tumor sample and each column a single-nucleotide or a structural variant driving the  progression; a 0/1 value models the absence/presence of that alteration in the sample. The tool can import data from plain,  MAF or GISTIC format files, and can fetch it from the cBioPortal for cancer genomics. Functions for  data manipulation and visualization are provided, as well as functions to import/export such data to other bioinformatics  tools for, e.g,  clustering or detection of mutually exclusive alterations. Inferred models can be visualized and tested for their confidence via bootstrap and cross-validation. TRONCO is used for  the implementation of the Pipeline for Cancer Inference. \\

\vspace{1.0cm}


{\em In this vignette, we will  give an overview of the package by presenting some of the functions that could be most commonly used to arrange a data-analysis pipeline, along with their parameters to customize TRONCO's functioning. Advanced example case studies  are available at the tool webpage}

\vspace{1.0cm}

% present a case study for the usage of the TRONCO package based on the work presented in the main \textit{CAPRI} paper. 
%We will start by loading the TRONCO package in \textsc{R} along with an example \textit{"dataset"} that comes within the package. }

\renewcommand{\arraystretch}{1.5}

\begin{tabular}{ll}
{\bf Version.}& {2.4.0} (April 2016) \\
{\bf Contact.}& \email{tronco@disco.unimib.it} \\
{\bf Bugs report.} & \url{https://github.com/BIMIB-DISCo/TRONCO} \\
{\bf Website.} & \url{https://sites.google.com/site/troncopackage}
\end{tabular}
\end{tcolorbox}

\SweaveOpts{concordance=TRUE}




\newpage

\tableofcontents



\section{Changelog} 

What changed version by   {\bf LUCA DEX}


\section{Algorithms and useful links} \label{sec:stuff}

\renewcommand{\arraystretch}{2}

\begin{center}
\begin{tabular}{l | p{5.0cm} | l  | p{6.0cm}}
{\bf Acronym} & {\bf Extended name} & {\bf App.} & {\bf Reference}\\ \hline

CAPRESE &  Cancer Progression Extraction with Single Edges &  Ens &  \href{http://www.ncbi.nlm.nih.gov/pubmed/25299648}{PLoS ONE, 9(10):e108358, 2014.}
\\ \hline

CAPRI &  Cancer Progression Inference &  Ens & \href{http://www.ncbi.nlm.nih.gov/pubmed/25971740}{Bioinformatics 31(18), 3016-3016, 2015.}\\ \hline

MST (Edmond) & Directed Minimum Spanning Tree with Mutual Information & Ind & \href{https://sites.google.com/site/troncopackage/}{In preparation.}\\ \hline
MST (Chow Liu) & Undirected Minimum Spanning Tree with Penalised Regularization & Ind & \href{https://sites.google.com/site/troncopackage/}{In preparation.}\\ \hline
MST (Prim) & Undirected Minimum Spanning Tree with Mutual Information & Ind & \href{https://sites.google.com/site/troncopackage/}{In preparation.}\\ \hline
 \end{tabular}
\end{center}
{\small {\bf Legend.} Ens.: ensemble-level with cross-sectional data; Ind.: individual-level with single-cell or multi-region data.}


\paragraph{External links to resources related to TRONCO.}

\begin{itemize}
\item  TRONCO was introduced in \href{http://www.ncbi.nlm.nih.gov/pubmed/26861821}{Bioinformatics. 2016 Feb 9. pii: btw035.} 
\item  TRONCO since version {\bf 2.3} is used to implement the {\bf Pipeline For Cancer Inference} described in \href{http://dx.doi.org/10.1101/027359}{Caravagna et al., 2016, under review}. 
\item Case studies featuring Atypical Chronic Myeloid Leukemia,  Colorectal Cancer, Clear Cell Renal Cell Carcinoma  and others are available at the tool \href{https://sites.google.com/site/troncopackage/}{webpage}. Code for replication of each of those study is made available through  \href{https://github.com/BIMIB-DISCo}{Bioinformatics Milano-Bicocca's Github}.


\end{itemize}





\section{Loading data}

\paragraph{Preliminaries.} 


\begin{mybox}
<<req>>=
library(TRONCO)
data(aCML)
data(crc_maf)
data(crc_gistic)
data(crc_plain)
@
\end{mybox}

TRONCO transforms input data in a sort of database-alike format, where three main fields are presente: {\tt genotypes} which contains the genomic signatures of the input samples, {\tt annotations} which provides an index to the events present in the data and {\tt types}, a field mapping type of events (e.g., mutations, CNAs, etc.) to colors for display visualization. Other annotations are generated when a dataset is augmented with some metadata.  A TRONCO object shall be edited by using TRONCO functions,  to avoid to create inconsistencies in its internal representation. Function {\tt is.compliant} can be used to test if a TRONCO object is consistent; the function is called by any TRONCO function before returning  a modified object, so to ensure that consistency is preserved -- {\tt is.compliant}  will raise an error if this is not the case.

\TRONCO{} supports the import of data from 3 formats. The Mutation Annotation Format (\textit{MAF}) is a tab-delimited file containing somatic and/or germline mutation annotations; the \textit{GISTIC} format for copy number alterations as defined by TCGA and a custom boolean matrix format where the user can directly specify the mutational profiles to be importend.   Through some data included in the package we will show how to load your datasets in TRONCO.  
 \begin{itemize}
\item[{\tt aCML}]  a TRONCO object that represents the {\em atypical Chronic Myeloid Leukemia} dataset by Piazza {\em et al.} (Nat. Gen. 2013 45(1):18-24).
\item[{\tt crc\_maf}]  a shortened version of the {\em colorectal cancer mutation data}   made available by the TCGA consortium within the COADREAD project\footnote{See \url{https://tcga-data.nci.nih.gov/docs/publications/coadread\_2012/} and our PicNiC case study (\S \ref{sec:stuff}) for the real analysis of such data.}
 \item[{\tt crc\_gistic}] from the same   TCGA  project, we also provide a shortened version of the focal CNAs in the GISTIC format where 1 represents a low level gain, 2 a high level gain, -1 a heterozygous loss of a gene and -2 its homozygous loss.
\item[{\tt crc\_plain}]  a custom boolean matrix where rows are samples, and columns represent events -- in this case alterations  in a certain gene. Notice with this format one could also custom types of alterations, for instance wider chromosomal aberrations or, in principle, epigenetic states (over-expression, methylated regions, etc.) that are persistent across tumor evolution. 


\end{itemize}

 
 

\subsection{Mutations annotated in a MAF format}
We use the function \texttt{import.MAF} to import a dataset in MAF format, in this case the following  TCGA dataset
\begin{mybox}
<<>>=
 head(crc_maf[, 1:10])
@
\end{mybox}

A default importation is done  without adding parameters to \texttt{import.MAF}. In this case, all mutations per gene will be considered equivalent, regardless of the type that is annotated in the MAF.  Also, all genes will be imported, and all samples.

\begin{mybox}
<<import.MAF, results=hide>>=
dataset_maf = import.MAF(crc_maf)
@
\begin{verbatim}
*** Importing from dataframe
Loading MAF dataframe ...DONE
*** Mutations names: using Hugo_Symbol
*** Using full MAF: #entries  17 
*** MAF report: TCGA=TRUE
Type of annotated mutations: 
[1] "Missense_Mutation" "Nonsense_Mutation"
*** [merge.mutation.types = T] Mutations will be merged and annotated as 'Mutation'
Number of samples: 9 
[TCGA = TRUE] Number of TCGA patients: 9 
Number of annotated mutations: 17 
Mutations annotated with "Valid" flag (%): 71 
Number of genes (Hugo_Symbol): 6 
Starting conversion from MAF to 0/1 mutation profiles (1 = mutation) :9 x 6 
|======================================================================| 100%
Starting conversion from MAF to TRONCO data type.
\end{verbatim}
\end{mybox}

See \S \ref{sec:view} to understand how to visualize a TRONCO dataset. In the above case -- where we see that mutations are annotated as {\tt Missense\_Mutation} or {\tt Nonsense\_Mutation}, if a gene in a sample has both, these will be merged to a unique {\tt Mutation} type. In this case a pair gene name with {\tt Mutation} will be what we call an ``event'' in our dataset -- e.g.,  APC {\tt Mutation}.

If one would like  to have two distinct events in the dataset, i.e., APC {\tt Missense\_Mutation} and APC {\tt Nonsense\_Mutation}, parameter {\tt merge.mutation.types} should be set to false in the call to {\tt import.MAF}. 

\begin{mybox}
<<import.MAF, results=hide>>=
dataset_maf = import.MAF(crc_maf, merge.mutation.types = FALSE)
@
\end{mybox}

Sometimes, we might want to filter out some of the entries in a MAF -- maybe restricting the type of genes, mutations or sample that we want to process. If one defines
{\tt filter.fun} as a function that returns {\tt TRUE} only for those entries which shall be considered, he gets a filter process which is applied to each row of the MAF file prior to transforming that into a TRONCO dataset. In this example we select only mutations annotated to APC -- we access that through the {\tt Hugo\_Symbol} flag of a MAF. 
\begin{mybox}
<<import.MAF,results=hide>>=
dataset_maf = import.MAF(crc_maf, filter.fun = function(x){ x['Hugo_Symbol'] == 'APC'} )
@
\begin{verbatim}
*** Importing from dataframe
Loading MAF dataframe ...DONE
*** Mutations names: using Hugo_Symbol
*** Filtering full MAF: #entries  17
*** Using reduced MAF: #entries  3
*** MAF report: TCGA=TRUE
Type of annotated mutations: 
[1] "Nonsense_Mutation"
*** [merge.mutation.types = T] Mutations will be merged and annotated as 'Mutation'
Number of samples: 3
[TCGA = TRUE] Number of TCGA patients: 3
Number of annotated mutations: 173
Mutations annotated with "Valid" flag (%): 33
Number of genes (Hugo_Symbol): 1
Starting conversion from MAF to 0/1 mutation profiles (1 = mutation) :3 x 1 
|======================================================================| 100%
Starting conversion from MAF to TRONCO data type.
\end{verbatim}
\end{mybox}

It is also sometimes convenient -- especially when working with data collected from a single individual patient -- to distinguish the type of mutations and their position in a gene, or if they are somehow annotated to COSMIC or other databases. For instance, we might want to want to use the {\tt MA.protein.change} annotation in the MAF file to get composite names such as TP53.R175H, TP53.R213, TP53.R267W etc. This can be done by setting {\tt paste.to.Hugo\_Symbol} to have the relevant name of the MAF annotation

\begin{mybox}
<<import.MAF, results=hide>>=
dataset_maf = import.MAF(crc_maf, 
	merge.mutation.types = FALSE, 
	paste.to.Hugo_Symbol = c('MA.protein.change')
	)
@
\end{mybox}

TRONCO supports custom  MAF files, where possibly not all the standard annotations are present, via {\tt irregular = TRUE}.


%We then use the function \texttt{view} to get a short summary of a dataset that we   loaded in TRONCO; this function reports on the number of samples and  events, plus some meta information that could be displayed graphically.  
%
%\begin{mybox}
%<<view>>=
%view(dataset_maf)
%@
%\end{mybox}

\subsection{Copy Number Variants annotated in the GISTIC format}
We use the function \texttt{import.GISTIC} to import a dataset in GISTIC format, in this case from
\begin{mybox}
<<>>=
crc_gistic
@
\end{mybox}

In its default execution all the data annotated in the file is imported. But in principle  it is possible to avoid to import some   genes or samples; in this case it is sufficient to use parameters {\tt filter.genes} and {\tt filter.samples} for this function.


\begin{mybox}
<<import.GISTIC>>=
dataset_gistic = import.GISTIC(crc_gistic)
@
\end{mybox}


 


\subsection{Custom alterations annotated in a boolean matrix}
One can annotate its custom type of alterations in a boolean matrix such as {\tt crc\_plain}
\begin{mybox}
<<>>=
crc_plain
@
\end{mybox}
In this case,  function \texttt{import.genotypes} will convert the matrix to a TRONCO  object where events' names and samples codes will be set from column and row names of the matrix. If this is not possible, these will be generated from templates. By default, the {\tt event.type} is set to {\tt variant} but one can specify a custom name for the alteration that is reported in the matrix
\begin{mybox}
<<import.genotypes>>=
dataset_plain = import.genotypes(crc_plain, event.type='myVariant')
@
\end{mybox}


\subsection{Downloading data from the cBio portal for cancer genomics}

TRONCO uses the R interface to cBio to query data from the portal. All type of data can be downloaded from the portal, which includes MAF/GISTIC data for a lot of different cancer studies. An example of interaction with the portal is archived at the tool's webpage. 

Here, we  show how to download lung cancer data somatic mutations for genes TP53, KRAS and PIK3CA,  from the lung cancer project run by TCGA, which is archived as  {\tt luad\_tcga\_pub} at cBio. If some of the parameters to {\tt cbio.query} are missing the function will become interactive by showing a list of possible data available at the portal.
\begin{mybox}
<<results=hide>>=
 data = cbio.query(
	genes=c('TP53', 'KRAS', 'PIK3CA'), 
	cbio.study = 'luad_tcga_pub',
	cbio.dataset = 'luad_tcga_pub_cnaseq', 
	cbio.profile = 'luad_tcga_pub_mutations'
	)
@
\begin{verbatim}
*** CGDS plugin for Cbio query.

Automatic CBIO study index: luad_tcga_pub
Automatic CBIO dataset index: luad_tcga_pub_cnaseq
Automatic CBIO profile index: luad_tcga_pub_mutations
Cancer codename: luad_tcga_pub
Cancer Ref.: Lung Adenocarcinoma (TCGA, Nature 2014)
Cancer Syn.: TCGA Lung Adenocarcinoma, containing 230 samples; 
Data codename: luad_tcga_pub_cnaseq
Data Ref.: Tumor Samples with sequencing and CNA data
Data Syn.: All tumor samples that have CNA and sequencing data (230 samples)
Samples codename: luad_tcga_pub_mutations
Data Ref.: Mutations
Data Syn.: Mutation data from whole exome sequencing.

Querying the following list of genes: TP53, KRAS, PIK3CA 
Symbol "." was replaced with "-" in sample IDs.

Data retrieved: 230 samples, 3 genes.
Retrieved also clinical data for samples: luad_tcga_pub_cnaseq
Data exported to file: luad_tcga_pub.luad_tcga_pub_cnaseq.luad_tcga_pub_mutations.Rdata
\end{verbatim}

\end{mybox}


\section{Data visualisation}

All examples in this section will be done with the the aCML dataset as reference.

\subsection{Summary report for a dataset and boolean queries}\label{sec:view}

We use the function \texttt{view} to get a short summary of a dataset that we   loaded in TRONCO; this function reports on the number of samples and  events, plus some meta information that could be displayed graphically.  

\begin{mybox}
<<view>>=
view(aCML)
@
%\tcblower
%ss
\end{mybox}






\subsection{Creating views with the ``as'' functions}

Several functions are available to create views over a dataset, with a set of parameter which can constraint the view -- as in the SELECT/JOIN approaches in databases. In the following examples we  show their execution with the default parameters, but  shorten their output to make this document readable.

The main ``as'' functions  are here documented.  \texttt{as.genotypes}, that we can use to get the matrix of ``genotypes'' that we imported.

\begin{mybox}
<<asgenotypes>>=
as.genotypes(aCML)[1:10,5:10]
@
\end{mybox}

Differently,  \texttt{as.events} and \texttt{as.events.in.samples}, that show tables with the events that we are processing in  all dataset or in a specific sample that we want to examine.

\begin{mybox}
<<asevents>>=
as.events(aCML)[1:5, ]
as.events.in.sample(aCML, sample = 'patient 2')
@
\end{mybox}

Concerning genes,  \texttt{as.genes} shows the mnemonic names of the genes (or chromosomes, cytobands, etc.) that we included in our dataset.

\begin{mybox}
<<asgenes>>=
as.genes(aCML)[1:8]
@
\end{mybox}

And \texttt{as.types} shows the types of alterations (e.g., mutations, amplifications, etc.) that we have  find in our dataset, and  function \texttt{as.colors} shows the list of the  colors which are associated to each type.

\begin{mybox}
<<astypes>>=
as.types(aCML)
as.colors(aCML)
@
\end{mybox}


A function \texttt{as.gene} can be used to display the alterations of a specific gene  across the samples

\begin{mybox}
<<asgene>>=
head(as.gene(aCML, genes='SETBP1'))
@
\end{mybox}

Views over samples can be created as well.  \texttt{as.samples} and \texttt{which.samples} list all the samples in the data, or return a list of samples that harbour a certain alteration. The former is 

\begin{mybox}
<<assamples1>>=
as.samples(aCML)[1:10]
@
\end{mybox}

and the latter is
 
\begin{mybox}
<<assamples>>=
which.samples(aCML, gene='TET2', type='Nonsense point')
@
\end{mybox}

A slightly different function, which manipulates the data,  is \texttt{as.alterations}, which transforms a dataset with events of different type  to events of a unique type, labeled ``Alteration''.

\begin{mybox}
<<asalterations, results=hide>>=
dataset = as.alterations(aCML)
@
\begin{verbatim}
*** Aggregating events of type(s) {Ins/Del, Missense point, Nonsense Ins/Del, 
	Nonsense point} in a unique event with label "Alteration".
Dropping event types Ins/Del, Missense point, Nonsense Ins/Del, Nonsense point 
	for 23 genes.  
|======================================================================| 100%
*** Binding events for 2 datasets.
\end{verbatim}
<<asalterations>>=
view(dataset)
@
\end{mybox}



 
When samples are enriched with stage information function  \texttt{as.stages} can be used to create a view over such table. Views over patterns can be created as well -- see Model Inference with CAPRI.

\subsection{Dataset size}

A set of functions allow to get the number of genes, events, samples, types and patterns in a dataset.

\begin{mybox}
<<number>>=
ngenes(aCML)
nevents(aCML)
nsamples(aCML)
ntypes(aCML)
npatterns(aCML)
@
\end{mybox}


\subsection{Oncoprints}

Oncoprints are the most effective  data-visualization functions in TRONCO. These are heatmaps where rows represent variants, and columns samples ({\em the reverse} of the input format required by TRONCO), and are annotated and displayed/sorted to enhance which samples have which mutations etc. 

A basic oncoprint of the included aCML dataset is shown below; more complex prints will be shown later in the vignette. 

\begin{mybox}
<<onco, fig=TRUE, include=FALSE, width=6, height=5>>=
oncoprint(aCML, cellheight=10, cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth, page=2]{vignette-onco}
\end{center}
\caption{Example \texttt{oncoprint} with  aCML data givesa graphical visualization of the variants that are annotated in the dataset -- with a color per event type -- and sorts samples to enhance exclusivity patterns among the events.}
\end{figure*}

\FloatBarrier

Oncoprints can be annotated; a special type of annotation is given by stage data. As this is not available for the aCML dataset, we create it randomly, just for the sake of showing how the oncoprint is enriched with this information. This is the random stage map that we create -- if some samples had no stage a NA would be added automatically. 


\begin{mybox}
<<stages>>=
stages = c(rep('stage 1', 32), rep('stage 2', 32))
stages = as.matrix(stages)
rownames(stages) = as.samples(aCML)
dataset = annotate.stages(aCML, stages = stages)
has.stages(aCML)
head(as.stages(dataset))
@
\end{mybox}

The {\tt as.stages} function can now be used to create a view over stages.
\begin{mybox}
<<>>=
head(as.stages(dataset))
@
\end{mybox}


After that the data is annotated via {\tt annotate.stages} function, we can again plot an oncoprint -- which this time will detect that the dataset has also stages associated, and will diplay those 

\begin{mybox}
<<onco-stages, fig=TRUE, include=FALSE, width=6, height=5>>=
oncoprint(dataset, cellheight=10, cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-stages}
\end{center}
\vspace*{.05in}
\caption{Example \texttt{oncoprint} output for aCML data with randomly annotated stages.}
\end{figure*}

\FloatBarrier

\subsection{Groups visualization (e.g., pathways)}

TRONCO provides functions to visualize groups of events, which in this case are called pathways -- though this could be any group that one would like to define. Aggregation happens with the same rational as the {\tt as.alterations} function, namely by merging the events in the group.

We make an example of a pathway called {\tt MyPATHWAY} involving genes SETBP1, EZH2 and WT1; we want it to be colored in red, and we want to have the genotype of each event to be maintened in the dataset. We proceed as follows  (R's output is omitted)..

\begin{mybox}
<<pathway, results=hide>>=
pathway = as.pathway(aCML,
    pathway.genes = c('SETBP1', 'EZH2', 'WT1'), 
    pathway.name = 'MyPATHWAY',
    pathway.color = 'red',
    aggregate.pathway = FALSE)
@
\end{mybox}

Which we then visualize with an oncoprint

\begin{mybox}
<<onco-pathway, fig=TRUE, include=FALSE, width=6.5, height=2.5>>=
oncoprint(pathway, title = 'Custom pathway',  font.row = 8, 
	cellheight = 15, cellwidth = 4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-pathway}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of a custom pathway called {\tt MyPATHWAY} involving genes SETBP1, EZH2 and WT1; the genotype of each event is shown.}
\end{figure*}

In TRONCO there is also a function which creates the pathway view and the corresponding oncoprint to  multiple pathways, when these are given as a list. We make here a simple example of two custom pathways (R's output is omitted).

\begin{mybox}
<<onco-pathway-viz, fig=TRUE, include=FALSE, width=6.5, height=1.8, results=hide>>=
pathway.visualization(aCML, 
    pathways=list(
        P1 = c('TET2', 'IRAK4'), 
        P2=c('SETBP1', 'KIT')), 
        aggregate.pathways=F)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-pathway-viz}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of a custom pair of pathways }
\end{figure*}

If we had to visualize just the signature of the pathway, we could set  {\tt aggregate.pathways=T}.

\begin{mybox}
<<onco-pathway-viz2, fig=TRUE, include=FALSE, width=6.5, height=1, results=hide>>=
pathway.visualization(aCML, 
    pathways=list(
        P1 = c('TET2', 'IRAK4'), 
        P2=c('SETBP1', 'KIT')), 
        aggregate.pathways=T)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-pathway-viz2}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of a custom pair of pathways, with events hidden.}
\end{figure*}


\section{Data manipulation}

All examples in this section will be done with the the aCML dataset as reference.

\subsection{Modifying events and samples}

TRONCO  provides functions for renaming the events that were included in a dataset, or the type associated to a set of events (e.g., a ``Mutation'' could be renamed to a ``Missense Mutation''). These functions work as follows

\begin{mybox}
<<rename>>=
dataset = rename.gene(aCML, 'TET2', 'new name')
dataset = rename.type(dataset, 'Ins/Del', 'new type')
as.events(dataset, type = 'new type')
@
\end{mybox}

and return a modified TRONCO object. More complex operations are also possible. For instance, two events with the same signature -- i.e., appearing in the same samples -- can be joined to a new event (see also Data Consolidation) with the same signature and a new name.

\begin{mybox}
<<join1>>=
dataset = join.events(aCML, 
    'gene 4',
    'gene 88',
    new.event='test',
    new.type='banana',
    event.color='yellow')
@
\end{mybox}

where in this case we also created a new event type, with its own color.

In a similar way we can decide to join all the events of two distinct types, in this case if a gene $x$ has signatures for both type of events, he will get a unique signature with an alteration present if it is either of the second {\em or} the second type 
\begin{mybox}
<<join2, results=hide>>=
dataset = join.types(dataset,
    'Nonsense point',
    'Nonsense Ins/Del')
@
\begin{verbatim}
*** Aggregating events of type(s) {Nonsense point, Nonsense Ins/Del}
in a unique event with label "new.type".
Dropping event types Nonsense point, Nonsense Ins/Del for 6 genes.
|======================================================================| 100%
*** Binding events for 2 datasets.
\end{verbatim}
<<join3>>=
as.types(dataset)
@
\end{mybox}

TRONCO also provides  functions for deleting specific events, samples or types.

\begin{mybox}
<<delete>>=
dataset = delete.gene(aCML, gene = 'TET2')
dataset = delete.event(dataset, gene = 'ASXL1', type = 'Ins/Del')
dataset = delete.samples(dataset, samples = c('patient 5', 'patient 6'))
dataset = delete.type(dataset, type = 'Missense point')
view(dataset)
@
\end{mybox}

\subsection{Modifying patterns}

TRONCO  provides functions to edit  patterns, which are supported only by CAPRI algorithm -- see Model Reconstruction with CAPRI to see a practical application of that.

\subsection{Subsetting a dataset}


It is very often the case that we want to subset a dataset by either selecting only some of its samples, or some of its events. Function \texttt{samples.selection} returns a dataset with only some selected samples.

\begin{mybox}
<<assamples>>=
dataset = samples.selection(aCML, samples = as.samples(aCML)[1:3])
view(dataset)
@
\end{mybox}

Function \texttt{events.selection}, instead, performs selection according to a filter of events. With this function, we can subset data according to a frequency, and we can force inclusion/exclusion of certain events by specifying their name. For instance, here we pick all events with a minimum frequency of 5\%, force exclusion of SETBP1 (all events associated), and inclusion of ETH1 and ETH2.
\begin{mybox}
<<eventsselection,results=hide>>=
dataset = events.selection(aCML,  filter.freq = .05, 
	filter.in.names = c('ETH1','ETH2'), 
	filter.out.names = 'SETBP1')
@
\begin{verbatim}
 *** Events selection: #events = 31, #types = 4 
        Filters freq|in|out = {TRUE, TRUE, TRUE}
        Minimum event frequency: 0.05 (3 alterations out of 64 samples).
|======================================================================| 100%
Selected 9 events.

[filter.in] Genes hold: ETH1, ETH2 ...  [0/2 found].
[filter.out] Genes dropped: SETBP1 ...  [1/1 found].
Selected 8 events, returning.
\end{verbatim}
<<eventsselection2>>=
as.events(dataset)
@
\end{mybox}

An example visualization of the data before and after the selection process can be obtained by combining the {\tt gtable} objects returned by {\tt oncoprint}. We here use 
{\tt gtable = T} to get access to have a  GROB table returned, and {\tt silent = T} to avoid that the calls to the function display on the device; the call to {\tt grid.arrange} displays the captured {\tt gtable} objects.

\begin{mybox}
<<onco-ex-sel, fig=TRUE, include=FALSE, width=8, height=7.5>>=
library(gridExtra)
grid.arrange(
	oncoprint(aCML, cellheight=6, cellwidth=4, gtable = T, 
		silent = T, font.row = 6)$gtable,
	oncoprint(dataset, cellheight=6, cellwidth=4, gtable = T, 
		silent = T, font.row = 6)$gtable,	
	ncol = 1	
)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=1]{vignette-onco-ex-sel}
\end{center}
\caption{Example \texttt{oncoprint} output for aCML data versus a selected subdataset.}
\end{figure*}


\section{Model inference}

We make use of the most of the  functions described above to show how to perform  inference with various algorithms. The reader should read first those sections  of the vignette to have an explanation of how those functions work.

\subsection{CAPRI}

CAPRI is an algorithm which naturally accommodates patterns, i.e., logical formulas that combine objects. In what follows, we show CAPRI's functioning by replicating the aCML case study presented in CAPRI's original paper -- see the main \textit{CAPRI} paper as a reference.  We consider a subset of all the genes in the dataset to be involved in patters; this list is based on the support  found in the literature.
\begin{mybox}
<<>>=
gene.hypotheses = c('KRAS', 'NRAS', 'IDH1', 'IDH2', 'TET2', 'SF3B1', 'ASXL1')
@
\end{mybox}

Regardless from which types of mutations we include, we select only the genes which appear alterated at least in the $5\%$ of the patients. Thus, we first transform the dataset into \textit{"Alteration"} (i.e., by collapsing all the event types for the same gene), and then we consider only the these events from the original dataset  (R's output is omitted).. 

\begin{mybox}
<<results=hide>>=
alterations = events.selection(as.alterations(aCML), filter.freq = .05)
@
\end{mybox}

To replicate the plots in the original CAPRI paper we can change the colors assigned to each type of event with the function \texttt{change.color}. 

\begin{mybox}
<<>>=
dataset = change.color(aCML, 'Ins/Del', 'dodgerblue4')
dataset = change.color(dataset, 'Missense point', '#7FC97F')
as.colors(dataset)
@
\end{mybox}

We now show a plot of the selected genes. Note that this plot has no title as by default the function \texttt{events.selection} does not add any. 

\begin{mybox}
<<onco-alterations, fig=TRUE, include=FALSE, width=6, height=1.5,results=hide>>=
oncoprint(alterations,font.row=12,cellheight=20,cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-alterations}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output}
\end{figure*}

\FloatBarrier

To proceed further with the example we  create the \texttt{dataset} to be used for the inference of the  model. From the original dataset  we select all the genes whose mutations are occurring at least the $5\%$ of the times, and we get that by the alterations profiles; also we force inclusion of all the events for the  genes involved in an hypothesis (those included in variable {\tt gene.hypotheses}).

\begin{mybox}
<<results=hide>>=
aCML.clean = events.selection(aCML,
	filter.in.names=c(as.genes(alterations), gene.hypotheses))
aCML.clean = annotate.description(aCML.clean, 
	'CAPRI - Bionformatics aCML data (selected events)')
@
\end{mybox}

We show a new oncoprint of this latest dataset where we annotate the genes in \texttt{gene.hypotheses} in order to identify them. The sample names are also shown. 

\begin{mybox}
<<onco-edited, fig=TRUE, include=FALSE, width=8, height=5.5,results=hide>>=
oncoprint(aCML.clean, 
    gene.annot = list(priors = gene.hypotheses),
    sample.id = TRUE,
    font.column=5,
    cellheight=10,
    cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-edited}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of data selected for aCML reconstruction annotated with the events which are part of a formula that we will input to CAPRI.}
\end{figure*}

\FloatBarrier


\subsubsection{Testable hypotheses via logical formulas (i.e., patterns)}

CAPRI is the only algorithm in TRONCO that supports hypotheses-testing of certain causal structures expressed as logical formulas. Every formula is transformed into a a CAPRI  pattern among events -- see the original CAPRI paper. For every hypothesis it is possible  to specify against which possible target it should be tested; if this is not done, it is tested against all other events in the dataset but those which constitute the pattern. An instance of a pattern tested against one other event is called an hypothesis.

\paragraph{Adding custom hypotheses.}

We now  add the hypotheses that are described in CAPRI's manuscript. Hypothesis of hard exclusivity (XOR) for NRAS/KRAS events (Mutation). This hypothesis is tested against all the events in the dataset. 
 
\begin{mybox}
<<>>=
aCML.hypo = hypothesis.add(aCML.clean, 'NRAS xor KRAS', XOR('NRAS', 'KRAS'))
@
\end{mybox}

We then try to include also a soft exclusivity (OR) pattern but, since its \textit{"signature"} is the same of the hard one just included, it will not be included. The code below is expected to rise an error. 
\begin{mybox}
<<eval=FALSE>>=
aCML.hypo = hypothesis.add(aCML.hypo, 'NRAS or KRAS',  OR('NRAS', 'KRAS'))
@
\end{mybox}

For the sake of better highlighting the perfect (hard) exclusivity among NRAS/KRAS mutations, one can have a further look at their alterations. 

\begin{mybox}
<<onco-kras-nras, fig=TRUE, include=FALSE, width=6, height=2.5>>=
oncoprint(events.selection(aCML.hypo, filter.in.names = c('KRAS', 'NRAS')),
    font.row=12, cellheight=16, cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth, page=2]{vignette-onco-kras-nras}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output to show the perfect (hard) exclusivity among NRAS/KRAS mutations in aCML.}
\end{figure*}

\FloatBarrier

We repeated the same analysis as before for other hypotheses and for the same reasons, we will include only the hard exclusivity pattern. 

\begin{mybox}
<<>>=
aCML.hypo = hypothesis.add(aCML.hypo,
    'SF3B1 xor ASXL1',
    XOR('SF3B1', OR('ASXL1')),
    '*')
@
\end{mybox}

This again would have caused error -- no pattern would have been included.

\begin{mybox}
<<eval=FALSE>>=
aCML.hypo = hypothesis.add(aCML.hypo,
    'SF3B1 or ASXL1',
    OR('SF3B1', OR('ASXL1')),
    '*')
@
\end{mybox}


Finally, we now do the same for genes TET2 and IDH2. In this case $3$ events for the gene TET2 are present, that is ``Ins/Del'', ``Missense point'' and ``Nonsense point''. For this reason, since we are not specifying any subset of such events to be considered, all TET2 alterations are used. Since the events present a perfect hard exclusivity, their patters will be included as a XOR. 

\begin{mybox}
<<>>=
as.events(aCML.hypo, genes = 'TET2') 
aCML.hypo = hypothesis.add(aCML.hypo,
    'TET2 xor IDH2',
    XOR('TET2', 'IDH2'),
    '*')
aCML.hypo = hypothesis.add(aCML.hypo,
    'TET2 or IDH2',
    OR('TET2', 'IDH2'),
    '*')
@
\end{mybox}

Which we visualize.

\begin{mybox}
<<onco-tet2-idh2, fig=TRUE, include=FALSE, width=7, height=2.5,results=hide>>=
oncoprint(events.selection(aCML.hypo, filter.in.names = c('TET2', 'IDH2')),
    font.row=12, cellheight=16, cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-tet2-idh2}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of  TET2 and IDH2 alterations in aCML.}
\end{figure*}


\FloatBarrier

\paragraph{Adding (automatically) hypotheses for homologous events.} We consider homologous events those having the same mnemonic name -- as of function {\tt as.genes} -- but events of different type. For instance, mutations and deletions of the same gene would be considered such. It could be a good idea to consider such events as equivalent, in terms of progression fitness, and as such we would like to build a pattern of exclusivity among them. TRONCO has a function to make this automatically which, by default, adds a soft exclusivity OR pattern among them. 


\begin{mybox}
<<results=hide>>=
aCML.hypo = hypothesis.add.homologous(aCML.hypo)
@
\begin{verbatim}
*** Adding hypotheses for Homologous Patterns
Genes: TET2, EZH2, CBL, ASXL1, CSF3R
Function: OR
Cause: *
Effect: *
|============================================================================| 100%
Hypothesis created for all possible gene patterns.
\end{verbatim}
\end{mybox}

The final dataset that will be given as input to CAPRI is  finally shown. This contains all the patterns, which in CAPRI's jargon are called lifted.

\begin{mybox}
<<onco-priors, fig=TRUE, include=FALSE, width=8, height=6.5,results=hide>>=
oncoprint(aCML.hypo, gene.annot = list(priors = gene.hypotheses), sample.id = TRUE, 
    font.row=10, font.column=5, cellheight=15, cellwidth=4)
@
\end{mybox}

\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-onco-priors}
\end{center}
\vspace*{.05in}
\caption{\texttt{oncoprint} output of the a dataset that has patterns that could be given as input to CAPRI to retrieve a progression model.}
\end{figure*}


\paragraph{Adding (automatically) hypotheses for a group of genes.}

The idea behind the previous function is generalized by {\tt hypothesis.add.group}, that add a set of hypotheses that can be combinatorially created out of a  group of genes. As such, this function can create an exponential number of hypotheses and should be used with caution as too many hypotheses, with respect to sample size, should not be included. 

This function takes, among its inputs, the top-level logical connective, AND/OR/XOR, a minimum/maximum pattern size -- to restrict the combinatorial sampling of subgroups --, plus a parameter that can be used to constrain the minimum event frequency. If, among the events included some of them have homologous, these are put automatically nested with the same logic of the {\tt hypothesis.add.group} function.

\begin{mybox}
<<hypo-add-hom>>=
dataset = hypothesis.add.group(aCML.clean, OR, group = c('SETBP1', 'ASXL1', 'CBL'))
@
\end{mybox}



\FloatBarrier

\paragraph{Querying, visualizing and manipulating CAPRI's patterns.}



We also provide functions to get the number of hypotheses and patterns present in the data.
\begin{mybox}
<<n-hypo-pat>>=
npatterns(dataset)
nhypotheses(dataset)
@
\end{mybox}

We can visualize any pattern or the elements involved in them with the following functions.
\begin{mybox}
<<as-patterns>>=
as.patterns(dataset)
as.events.in.patterns(dataset)
as.genes.in.patterns(dataset)
as.types.in.patterns(dataset)
@
\end{mybox}

Similarily, we can enumerate the added hypotheses with the funcion \texttt{as.hypotheses}, and delete certain patterns and hypotheses. Deleting a pattern consists in deleting all of its hypotheses.

\begin{mybox}
<<as-hypotheses>>=
head(as.hypotheses(dataset))
dataset = delete.hypothesis(dataset, event = 'TET2')
dataset = delete.pattern(dataset, pattern = 'OR_ASXL1_CBL')
@
\end{mybox}

It is sometimes of help to plot some information about a certain combination of events, and a target -- especially to disentangle the proper logical connectives to use.
Here, we test genes SETBP1 and ASXL1 versus Missense point mutations of  CSF3R, and observe that the majority of observations are mutually exclusive, but almost half of the 
CSF3R mutated samples with Missense point mutations do not harbout any mutation in SETBP1 and ASXL1.

\begin{mybox}
<<pattern-plot, fig=TRUE,include=FALSE>>=
tronco.pattern.plot(aCML.hypo,
    group = as.events(aCML, genes=c('SETBP1', 'ASXL1')),
    to = c('CSF3R', 'Missense point'),
    legend.cex=1.5,
    label.cex=1.9)
@
\end{mybox}

\incfig[ht]{vignette-pattern-plot}{0.8\textwidth}{Barplot to show an hypothesis: here we test genes SETBP1 and ASXL1 versus Missense point mutations of  CSF3R }{}


\FloatBarrier

It is also possible to create a circle plot where we can observe the contribution of genes SETBP1 and ASXL1 in every match with a Missense point mutations of  CSF3R.

\begin{mybox}
<<pattern-plot-circos, fig=TRUE,include=FALSE,results=hide>>=
tronco.pattern.plot(aCML.hypo,
    group = as.events(aCML, genes=c('TET2', 'ASXL1')),
    to = c('CSF3R', 'Missense point'),
    legend.cex=1.0,
    label.cex=1.0,
    mode='circos')
@
\end{mybox}

\incfig[ht]{vignette-pattern-plot-circos}{0.8\textwidth}{Circos to show an hypothesis: here we test genes SETBP1 and ASXL1 versus Missense point mutations of  CSF3R.}{}


\FloatBarrier


\subsubsection{Model reconstruction}

We run the inference of the model by CAPRI algorithm with its default parameter: we use both AIC and BIC as regularizators, Hill-climbing as heuristic search of the solutions and exhaustive bootstrap ({\tt nboot} replicates or more for Wilcoxon testing, i.e., more iterations can be performed if samples are rejected), p-value are set at $0.05$. We set the seed for the sake of reproducibility. 

\begin{mybox}
<<>>=
model.capri = tronco.capri(aCML.hypo, boot.seed = 12345, nboot=1)
@
\end{mybox}

%<<>>=
%model.capri = tronco.capri(aCML.hypo, boot.seed = 12345, nboot=10)
%@


\subsection{CAPRESE}

\TRONCO{} provides also others algorithms for the same problem but with different assumpions on the valid solutions. Besides CAPRI, the CAPRESE algorithm to reconstruct progression trees and three algorithms based on the formulation of the same problem in terms of minimum spamming tree (exploiting results from Edmons, Prim and Chow Liu) are also provided (see the respective papers). We show the execution of these algorithms.

<<caprese-plot, fig=TRUE,include=FALSE>>=
model.caprese = tronco.caprese(aCML.clean)
model.caprese = annotate.description(model.caprese,
    'CAPRESE - Bionformatics aCML data (selected events)')
tronco.plot(model.caprese, fontsize = 14, scale.nodes = 0.6,
    legend.cex = 0.6, legend.pos = 'top')
@
\incfig[ht]{vignette-caprese-plot}{0.8\textwidth}{aCML Reconstructed model}{with CAPRESE}

\FloatBarrier

\subsection{Minimum Spanning Tree - EDMOND}


<<edmonds-plot, fig=TRUE,include=FALSE>>=
model.edmonds = tronco.mst.edmonds(aCML.clean, nboot = 10, boot.seed = 12345)
model.edmonds = annotate.description(model.edmonds,
    'EDMONDS - Bionformatics aCML data (selected events)')
@

\FloatBarrier


\subsection{Minimum Spanning Tree - CHOWLIU}

<<chow-liu-plot, fig=TRUE,include=FALSE>>=
model.chowliu = tronco.mst.chowliu(aCML.clean, nboot = 10, boot.seed = 12345)
model.chowliu = annotate.description(model.chowliu,
    'CHOW LIU - Bionformatics aCML data (selected events)')
@

\FloatBarrier


\subsection{Minimum Spanning Tree - PRIM}


<<prim-plot, fig=TRUE,include=FALSE>>=
model.prim = tronco.mst.prim(aCML.clean, nboot = 10, boot.seed = 12345)
model.prim = annotate.description(model.prim,
    'PRIM - Bionformatics aCML data (selected events)')
@

\FloatBarrier


\section{Post-reconstruction}

TRONCO provides functions to plot a model, access information about the probabilities used to extract it from data, and two types of confidence measures: those used to infer the model, and those computed a posteriori from it.

Function {\tt view} provides updated information about a model if this is available. 
\begin{mybox}
<<>>=
view(model.capri)
@
\end{mybox}

\subsection{Visualizing a reconstructed model}

We can plot a model by using function {\tt tronco.plot}. Here, we plot the aCML model inferred by CAPRI with BIC and AIC as a regolarizator. We set some parameters to get a nice plot (scaling etc.), and distinguish the edges detected by the two regularization techniques. The confidence of each edge is shown  in terms of temporal priority and probability raising (selective advantage scores) and hypergeometric testing (statistical relevance of the dataset of input). Events are annotated as in the oncoprint.

\begin{mybox}
<<capri-plot, fig=TRUE,include=FALSE>>=
tronco.plot(model.capri, 
	fontsize = 12, 
	scale.nodes = 0.6, 
	confidence = c('tp', 'pr', 'hg'), 
	height.logic = 0.25, 
	legend.cex = 0.5, 
	pathways = list(priors = gene.hypotheses), 
	label.edge.size = 8,
	legend.pos='top'
	)
@
\end{mybox}

\incfig[ht]{vignette-capri-plot}{0.9\textwidth}{aCML model reconstructed by CAPRI with  with BIC as a regolarizator; the confidence of each edge is shown both in terms of temporal priority and probability raising (selective advantage scores) and hypergeometric testing (statistical relevance of the dataset of input). 
}
%
\FloatBarrier

We can also make a multiplot with this function,  which in this case we do by showing the models inferred by the other algorithms based on Minimum Spanning Trees.

\begin{mybox}
<<mst-plot, fig=TRUE,include=FALSE,results=hide>>=
par(mfrow=c(3,1))
tronco.plot(model.edmonds, fontsize = 10, scale.nodes = 0.6, legend = F)
tronco.plot(model.chowliu, fontsize = 10, scale.nodes = 0.6, legend = F)
tronco.plot(model.prim, fontsize = 10, scale.nodes = 0.6, legend = F)
@
\end{mybox}

\incfig[ht]{vignette-mst-plot}{0.8\textwidth}{aCML Reconstructed model by MST algorithms with EDMONDS, CHOW LIU and PRIM variants.}


\subsection{Accessing information within a model (e.g., confidence)}

We can visualize a summary of the parameters   used for the reconstruction, test if an object has a model or delete it (which shall be done to retrieve the original dataset).
\begin{mybox}
<<>>=
 as.data.frame(as.parameters(model.capri))
has.model(model.chowliu)
dataset = delete.model(model.chowliu)
@
\end{mybox}


\paragraph{Model structure.}
A set of functions can be used to visualize the content of object which contains the reconstructed model. For instance, we can access the adjacency matrix of a model by using {\tt as.adj.matrix} which will return a matrix for each one of the regularizators used -- in this case because CAPRI was run with both BIC/AIC.

\begin{mybox}
<<>>=
str(as.adj.matrix(model.capri))
@
\end{mybox}




\paragraph{Empirical probabilities.}

Every model is inferred by estimating the empirical marginal, joint and conditional probabilities for all the events, from input data. These in some cases are estimated by a bootstrap procedure (see the algorithms implemented). TRONCO has functions to extract such table, that could be in turn printed by using external  functions for, e.g., heatmap visualization (see below for an example via the {\tt pheatmap} package). We show these functions working with the CAPRI model; in this case the tables are the same for both BIC/AIC structures as they are computed before performing penalized likelihood-fit. The marginal  $P(x)$ for $x$ an event in the dataset are obtained by {\tt as.marginal.probs}. 
\begin{mybox}
<<>>=
marginal.prob = as.marginal.probs(model.capri)
head(marginal.prob$capri_bic)
@
\end{mybox}

Similarly,   the joint $P(x,y)$ for every pair of events in the dataset is given by {\tt as.joint.probs}.
\begin{mybox}
<<>>=
joint.prob = as.joint.probs(model.capri, models='capri_bic')
joint.prob$capri_bic[1:3, 1:3]
@
\end{mybox}

And {\tt as.conditional.probs} finally gives the conditional $P(x\mid y)$ for every edge in the dataset.
\begin{mybox}
<<>>=
conditional.prob = as.conditional.probs(model.capri, models='capri_bic')
head(conditional.prob$capri_bic)
@
\end{mybox}

\paragraph{Confidence measures.}

Confidence scores  can be accessed by function {\tt as.confidence}, which takes as parameter the type of confidence measure that one wants to access to. This will work for either confidence measures assessed before reconstructing the model -- if available --, or afterwards.
\begin{mybox}
<<>>=
str(as.confidence(model.capri, conf = c('tp', 'pr', 'hg')))
@
\end{mybox}



Other functions  visualize  tables summarizing the  statistics for each edge in the model, For instance, if one uses function {\tt as.selective.advantage.relations}  the  p-values for temporal priority, probability raising and hypergeometric testing, as well as other information about each edge  can be accessed, e.g., the number of observations for the upstream and the downstream events.

\begin{mybox}
<<selective-advantage>>=
as.selective.advantage.relations(model.capri)
@
\end{mybox}




\subsection{Model confidence via non-parametric, parametric and statistical bootstrap}

TRONCO provides three different strategies to perform  bootstrap and assess confidence of each edge in terms of a score in the range [0, 100] (100 is the highest confidence). Non-parametric (default), parametric and statistical bootstrap strategies are available, and can be executed by calling function {\tt tronco.bootstrap} with {\tt type} parameter set appropriately. This function is parallel, and parameter {\tt cores.ratio} (default 1) can be used to percentage of available cores that shall be used to compute the scores.
Parameter {\tt nboot} controls the number of bootstrap iterations.

\begin{mybox}
<<>>=
model.boot = tronco.bootstrap(model.capri, nboot=1)
model.boot = tronco.bootstrap(model.boot, nboot=1, type = 'statistical')
@
\end{mybox}

%<<>>=
%model.boot = tronco.bootstrap(model.capri, nboot=10)
%@

Bootstrap scores can be annotated to the {\tt tronco.plot} output by setting them via the confidence parameter {\tt confidence=c('npb', 'sb')}. In this case edge thickness will be proportional to the non-parametric ({\tt npb}) scores -- the last in the {\tt confidence}.
\begin{mybox}
<<figplotboot, fig=TRUE,include=FALSE>>=
tronco.plot(model.boot, 
	fontsize = 13, 
	scale.nodes = .6,   
	confidence=c('sb', 'npb'), 
	height.logic = 0.25, 
	legend.cex = .5, 
    	pathways = list(priors= gene.hypotheses), 
	label.edge.size=10, 
	legend.pos = 'top'
	)
@
\end{mybox}

\incfig[ht]{vignette-figplotboot}{0.9\textwidth}{aCML CAPRI model visualized with both non-parametric and statistical bootstrap scores annotated. Edge thickness is proportional to   the non-parametric  scores.}
\FloatBarrier


Bootstrap scores can extracted or visualized even with other TRONCO functions. For instance, we can accessall scores via {\tt as.bootstrap.scores}, which resembles  function{\tt as.selective.advantage.relations} and will display the scores per edge. Notice that even function {\tt view} gives an update output by mentioning the available bootstrap scores.

\begin{mybox}
<<bootstrap-table>>=
as.bootstrap.scores(model.boot)
view(model.boot)
@
\end{mybox}

If we want to access a matrix with the scores and visualize that in a heatmap we can use for instance the {\tt pheatmap} package. In this case, we can 

\begin{mybox}
<<hboot, fig=TRUE,include=FALSE>>=
library(pheatmap)
pheatmap(keysToNames(model.boot, as.confidence(model.boot, conf = 'sb')$sb$capri_aic) * 100, 
           main =  'Statistical bootstrap scores for AIC model',
           fontsize_row = 6,
           fontsize_col = 6,
           display_numbers = T,
           number_format = "%d"
           )
@
\end{mybox}


\begin{figure*}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth, page=2]{vignette-hboot}
\end{center}
\vspace*{.05in}
\caption{Example visualization with the {\tt pheatmap} package of the bootstrap scores for a model.}
\end{figure*}


\subsection{Model confidence via cross-validation (entropy loss, prediction and posterior classification errors)}

TRONCO implements $k$-fold cross-validation routines (from the {\tt bnlearn} package) to provide estimates of the following statistics:
\begin{itemize}
\item  the {\em negative entropy} (via {\tt tronco.kfold.eloss}) of a whole model ? i.e., the negated expected log-likelihood of the test set for the Bayesian network fitted from the training set.
\item the {\em prediction error} (via {\tt tronco.kfold.prederr}) for a single node $x$ and its parents set $X$ -- i.e.,  how precisely we can predict the values of $x$ by using only the information present in its local distribution, via $X$.
\item the {\em posterior classification error} (via {\tt tronco.kfold.posterr})  for a single node $x$ and one of its parent node $y \in X$ -- i.e., the values of $x$ are predicted using only the information present in $y$ by likelihood weighting and Bayesian posterior estimates.
\end{itemize}
 
 To speed up we assess these only on the CAPRI model assessed via  BIC regularization.
\begin{mybox}
<<kfold>>=
model.boot = tronco.kfold.eloss(model.boot, models = 'capri_bic')
model.boot = tronco.kfold.prederr(model.boot, models = 'capri_bic')
model.boot = tronco.kfold.posterr(model.boot, models = 'capri_bic')
@
\end{mybox}

These results can be visualized in terms of summary tables, as for the other confidence scores.

\begin{mybox}
<<as-kfold>>=
as.kfold.eloss(model.boot, models = 'capri_bic')
as.kfold.prederr(model.boot, models = 'capri_bic')
as.kfold.posterr(model.boot, models = 'capri_bic')
@
\end{mybox}

Notice that these can be combined to create a nice table with all these statistics as follows
\begin{mybox}
<<as-kfold>>=
tabular = function(obj, M){
  tab = Reduce(
    function(...) merge(..., all = T), 
      list(
      as.selective.advantage.relations(obj, models = M),
      as.bootstrap.scores(obj, models = M),
      as.kfold.prederr(obj, models = M),
      as.kfold.posterr(obj,models = M)
    )
  )
  
   # merge reverses first with second column
  tab = tab[, c(2,1,3:ncol(tab))]
  tab = tab[order(tab[, paste(M, '.NONPAR.BOOT', sep='')], na.last = TRUE, decreasing = TRUE), ]
  
  return(tab)
}

head(tabular(model.boot, 'capri_bic'))
@
\end{mybox}


We finally show the plot of the model with the confidences by cross-validation.

\begin{mybox}
<<plot-conf, fig=TRUE,include=FALSE>>=
tronco.plot(model.boot, 
	scale.nodes = .6, 
	models="capri_bic", 
	confidence=c('npb', 'eloss', 'prederr', 'posterr'), 
	height.logic = 0.25, 
	legend.cex = .5, 
	pathways = list(priors= gene.hypotheses), 
	label.edge.size=6)
@
\end{mybox}

\incfig[ht]{vignette-plot-conf}{0.9\textwidth}{aCML Reconstructed model}
{After bootstrap.}


\end{document}
